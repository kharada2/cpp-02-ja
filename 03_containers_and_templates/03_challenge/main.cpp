#include <iostream>

#include "benchmark.hpp"

int main() {
  std::cout << "vector::"
            << " ";
  benchmark<std::vector<int>>();
  std::cout << std::endl;

  std::cout << "list::"
            << " ";
  benchmark<std::list<int>>();
  std::cout << std::endl;

  std::cout << "deque::"
            << " ";
  benchmark<std::deque<int>>();
  std::cout << std::endl;
  return 0;
}

// 調べたメモ
// 最適なコンテナは、アプリケーションによって異なりますが、以下の一般的なガイドラインがあります。
// std::vector:
// ランダムアクセスが速いため、要素へのランダムなアクセスが多い場合に適しています。要素の挿入や削除が末尾以外では遅いです。
// std::list:
// 要素の挿入や削除が高速であり、イテレータが有効な間は妨げられません。ただし、ランダムアクセスが遅いため、要素の位置にアクセスする必要がある場合には適していません。
// std::deque: 両端からの挿入と削除が高速です。要素の追加や削除が中央付近でも高速であり、ランダムアクセスも速いです。
// このプログラムを実行して得られる結果を見て、アプリケーションの要件に最も適したコンテナを選択することができます。

// std::vector: メモリが連続しているため、プッシュとポップの操作が最も高速であると予想されます。
// std::deque:
// 両端からの挿入と削除が高速であり、ランダムアクセスも速いため、std::vectorに近いパフォーマンスを提供すると予想されます。
// std::list:
// ノードベースのデータ構造であり、要素の挿入と削除は高速ですが、ランダムアクセスが遅いため、最も遅いと予想されます。